##question

문제]

정렬되지 않은 학생들의 임의의 점수를 입력하여 석차를 계산하는 프로그램을 작성하시오. 점수는 동점이 있을 수 있으며, 이러한 경우 같은 석차로 처리한다. 예를 들어 5명의 점수 100, 90, 76, 60, 90이 입력되었다면 석차는 2등이 2명이고 3등은 없다. (단, 점수가 가장 높은 학생을 1등으로 한다.)

입력
1) 첫 번째 줄은 처리할 점수의 개수 n ( n <= 200 ) ※ 조건수정:2012.10.6

2) 두 번째 줄은 처리할 점수 데이터 (0~100점)

(단, 각각의 점수는 빈칸으로 구별한다.)
입력 예시   
10
60 34 55 100 90 76 60 90 80 87

출력 예시
60 7
34 10
55 9
100 1
90 2
76 6
60 7
90 2
80 5
87 4


#start time : 2021.02.19 6:13
#end time : 2021.02.19 6:20

#시도1()
//구조체에 대한 이해가 아직 부족해서 교재로 더 공부하고 오겠다.

#2021.02.20
// 점수와 등수 포함한 !구조체 student배열!을 만들고 그안에 input값을 넣는다.
// 점수 등수를 포함하고 성적순으로 배치된 !단순 연결리스트(Ranking)!를 만든다.
// 함수에 자신의 점수를 넣으면 Ranking 리스트에서 자신의 위치가 어디인지 파악하고 배열에 넣으며 Ranking에 등록한다. 

#2021.02.21
#start time : 2021.02.21 22:20
#end time : 2021.02.19 22:43
#43min

#시도1
#include <stdio.h>
#include <stdlib.h>

typedef struct student{
    int score;
    int rank;
}student;

typedef struct rank_node{
    int data;
    int rank;
    struct rank_node *link;
}rank_node;

typedef struct rank_h{
    rank_node *H;
}rank_h;

int Ranking(rank_h *H,int score){
    rank_node *n=(rank_node *)malloc(sizeof(rank_node));
    n->data=score;
    rank_node *p;
    p=H;
    if(p==NULL){ // 랭킹에 아무도 없을때
        H=n;
        n->rank=1;
        n->link=NULL;
        return n->rank; // 인풋 score의 등수를 반환해줌
    }
    if(H->data<=n->data){ // 제일 높은 점수가 들어왔을 때
        H=n;
        n->link=NULL;
        n->rank=1;
    }
    else{
        while(p->link->data>n->data){ // 포인터를 점수가 들어가야할 위치를 찾는 과정 (동점일 경우 제일 최신에 들어온 것이 젤앞에온다.)
            p=p->link;
        }
        n->rank=p->rank+1;
        n->link=p->link;
        p->link=n;
    }
    while(n->data == p->data){ // 동점이 있으면 동점 끝에 노드부터 rank를 1씩 올리기위한 포인터 움직임.
        p=p->link;
    }
    while(p->link!=NULL){//마지막 전 노드까지 rank를 1씩 증가시켜줌 
        p->rank=p->rank+1;
    }
    p->rank=p->rank+1; //마지막 노드 rank를 1 증가시켜줌
    return n->rank; // 인풋 score의 등수를 반환해줌
}

int main() {
    int n;
    scanf("%d",&n);
    student* A=(student*)malloc(sizeof(student) * n);
    rank_h *H=(rank_h*)malloc(sizeof(rank_h));
    
    for(int i=0;i<n;i++){
        scanf("%d ",&A[i].score);
    }
     for(int i=0;i<n;i++){
        printf("%d ",A[i].score);
    }
    for(int i=0;i<n;i++){
        A[i].rank=Ranking(H,A[i].score);
    }
    return 0;
}
#오류 : if(H->data<=n->data){ // 제일 높은 점수가 들어왔을 때 
//H->data를 찾지함

#2021.02.23

#시도1 오류의 문제점
//H는 rank_h타입의 변수일뿐 rank_h구조체 안에 H랑 겹쳐서 헷갈렸다 헷갈리지않게 Ranking함수 인자를 Head로 바꾸고 실행.

#시도2(시도1의 오류를 고친 후)
#오류
//유효하지않는 주소를 참조하려함.
//while(p->link->data>n->data){ // 포인터를 점수가 들어가야할 위치를 찾는 과정 (동점일 경우 제일 최신에 들어온 것이 젤앞에온다.)
            p=p->link;
        }
//아마 여기가 문제일거같다. n->data가 제일 작은 수 일경우 끝까지 가게되는데 p->link가 NULL일 경우 p->link->data는 유효하지않는 곳이다.
//그래서 while(p->link!=NULL && (p->link->data) > (n->data)) 이렇게 조건문을 고친다.

