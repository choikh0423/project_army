##question

문제]

정렬되지 않은 학생들의 임의의 점수를 입력하여 석차를 계산하는 프로그램을 작성하시오. 점수는 동점이 있을 수 있으며, 이러한 경우 같은 석차로 처리한다. 예를 들어 5명의 점수 100, 90, 76, 60, 90이 입력되었다면 석차는 2등이 2명이고 3등은 없다. (단, 점수가 가장 높은 학생을 1등으로 한다.)

입력
1) 첫 번째 줄은 처리할 점수의 개수 n ( n <= 200 ) ※ 조건수정:2012.10.6

2) 두 번째 줄은 처리할 점수 데이터 (0~100점)

(단, 각각의 점수는 빈칸으로 구별한다.)
입력 예시   
10
60 34 55 100 90 76 60 90 80 87

출력 예시
60 7
34 10
55 9
100 1
90 2
76 6
60 7
90 2
80 5
87 4


#start time : 2021.02.19 6:13
#end time : 2021.02.19 6:20

#내코드
#include <stdio.h>
#include <stdlib.h>

//11:55
//12:06
typedef struct student{
    int score;
    int rank;
}student;

int main() {
    int n;
    int cnt=1;
    scanf("%d",&n);
    student *A=(student *)malloc(sizeof(student)*n);
    for(int i=0;i<n;i++){
        scanf("%d ",&A[i].score);
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<i;j++){
            if(A[i].score<A[j].score){
                cnt++;
            }
            else if(A[i].score>A[j].score){
                A[j].rank+=1;
            }
        }
        A[i].rank=cnt;
        cnt=1;
    }
    for(int i=0;i<n;i++){
        printf("%d %d\n",A[i].score,A[i].rank);
    }
}

#시도1()
//구조체에 대한 이해가 아직 부족해서 교재로 더 공부하고 오겠다.

#2021.02.20
// 점수와 등수 포함한 !구조체 student배열!을 만들고 그안에 input값을 넣는다.
// 점수 등수를 포함하고 성적순으로 배치된 !단순 연결리스트(Ranking)!를 만든다.
// 함수에 자신의 점수를 넣으면 Ranking 리스트에서 자신의 위치가 어디인지 파악하고 배열에 넣으며 Ranking에 등록한다. 

#2021.02.21
#start time : 2021.02.21 22:20
#end time : 2021.02.19 22:43
#43min



#시도1

#오류 : if(H->data<=n->data){ // 제일 높은 점수가 들어왔을 때 
//H->data를 찾지함

#2021.02.23

#시도1 오류의 문제점
//H는 rank_h타입의 변수일뿐 rank_h구조체 안에 H랑 겹쳐서 헷갈렸다 헷갈리지않게 Ranking함수 인자를 Head로 바꾸고 실행.

#시도2(시도1의 오류를 고친 후)
#오류
//유효하지않는 주소를 참조하려함.
//while(p->link->data>n->data){ // 포인터를 점수가 들어가야할 위치를 찾는 과정 (동점일 경우 제일 최신에 들어온 것이 젤앞에온다.)
            p=p->link;
        }
//아마 여기가 문제일거같다. n->data가 제일 작은 수 일경우 끝까지 가게되는데 p->link가 NULL일 경우 p->link->data는 유효하지않는 곳이다.
//그래서 while(p->link!=NULL && (p->link->data) > (n->data)) 이렇게 조건문을 고친다.

#시도3(시도2의 오류를 고친후)
#오류
//CPTtime이 비정상적으로 크게 나온다 무한루프를 돌고있을 것이다.
//세가지 while문중에 문제가 있을 것이다.
//첫번째 while문은 정상적으로 빠져나온 것을 확인했다.
//세번째 while문이 계속 돌고있음을 확인.// p->link!=NULL이라는 조건문인데 마지막노드가 NULL이라는 주소를 갖지않는 것같다. 위에 코드에서 문제점을 찾아야한다.
//그게아니라 세번째 while문안에 p->link=p->link->link라는 포인터를 옮겨주는 실행문을 안넣어줬었다.

#시도4(시도3의 오류를 고친후)
input
10
60 34 55 100 90 76 60 90 80 87
output
60 34 55 100 90 76 60 90 80 87 
60 1
34 2
55 3
100 1
90 2
76 3
60 4
90 5
80 6
87 7
#실패
//등수가 자기 멋대로다..100점이 1등인걸보니 젤높은점수가 들어왔을 때 실행문은 제대로 되는 것같다.
//왜인지 들어온 순서대로 순위가 매겨지다가 100점이 들어간이후로 다시 1위부터 들어온순서대로 랭킹이 매겨지고있다.
//while(p->link!=NULL&&(p->link->data) > (n->data))p=p->link;이 안되고있다.
//if(Head->H->data<=n->data){ // 제일 높은 점수가 들어왔을 때
        Head->H=n;
        n->link=NULL;
        n->rank=1;
    }
    //여기서 Head->H가 바꼈는데 p는 바뀌기전에 포인터를 가지고있음. 따라서 제일 높은 점수가 들어왔을 때
    //p를 다시 Head->H 로 초기화해야된다고 생각함.
    
  #시도5(시도4의 실패이유를 고친후)
  //while(n->data == p->data){ // 동점이 있으면 동점 끝에 노드부터 rank를 1씩 올리기위한 포인터 움직임.
        printf("동점발견!\n");
        p=p->link;
    }
  //에서 유효하지않는 주소참조 오류가뜬다.
  //생각해보니까 마지막에 student구조체를 출력할때도 오류가 있다. 이미 넣은애들도 계속바꿔줘야한다.
  //처음 알고리즘을 잘못짠거같다. 다시 짜오겠다.
   
#2021.02.24
#11:52 ~ 12:06

#시도6(성공)-O(N^2)
//시간복잡도 O(N^2)안나오게 해보려했지만 도무지 방법이 떠오르지않아서 그냥해버렸다
//앞에서부터 차근차근 자기보다 큰게 몇게있는지 조사후 본인의 rank에 넣고 작은애들은 rank 1씩 더해주는 방식으로 했다.
//그래도 문제에서 n<=200이라고했으니 최선의 알고리즘과 시간차이는 거의없다고 생각한다.
