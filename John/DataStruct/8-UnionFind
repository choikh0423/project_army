#start_time : 2021.03.16 12:12
#end_time :

#배운점
//unionfind 란 쉽게 말해 합집합찾기알고리즘이다.
//서로 다른 두노드를 선택했을 때 두 노드가 같은 그래프 안에 속하는지 확인하는 알고리즘이다.
//이걸 배우는 이유는 크루스칼 알고리즘 할때 트리를 생성할때 순환이 생기면 안되는데 그 역할을 할 수 있는 것이 unionfind이다.

#출력

#내코드
#include <stdio.h>
#include <stdlib.h>

#define Max_Vertex 30

typedef struct Node{
    int vertex;
    int weight;
    struct Node *next;
}Node;


typedef struct GraphList{
    Node *graph[Max_Vertex];
    int parent[Max_Vertex];
    int vertexCnt;
}GraphList;


GraphList* Create_Graph(){
    GraphList* Graph=(GraphList*)malloc(sizeof(GraphList));
    Graph->vertexCnt=0;
    for(int i=0;i<Max_Vertex;i++){
        Graph->graph[i]=NULL;
    }
    for(int i=0;i<Max_Vertex;i++){
        Graph->parent[i]=i;
    }
    return Graph;
}

void addvertex(GraphList *H,int v){
    if(H->vertexCnt>=Max_Vertex){
        printf("정점개수 초과입니다.\n");
        return;
    }
    H->vertexCnt++;
}

void addedge(GraphList *H, int v1, int v2,int w){
    if(v1>=H->vertexCnt || v2>=H->vertexCnt){
        printf("없는 정점입니다.\n");
        return;
    }
    Node *newNode=(Node*)malloc(sizeof(Node));
    newNode->vertex=v2;
    newNode->weight=w;
    newNode->next=H->graph[v1];
    H->graph[v1]=newNode;
    
}

void print_Graph(GraphList *H){
    Node *horse;
    for(int i=0;i<H->vertexCnt;i++){
        horse=H->graph[i];
        printf("정점[%d]->",i);
        while(horse!=NULL){
            printf("%d(%d)-> ",horse->vertex,horse->weight);
            horse=horse->next;
        }
        printf("\n");
    }
    return;
}

int UnionFind(GraphList *H,int v1, int v2){
    int small;
    if(v1>=H->vertexCnt || v2>=H->vertexCnt){
        printf("없는 정점입니다.\n");
        return;
    }
    if(v1<v2){
        H->parent[v2]=v1;
    }else H->parent[v1]=v2;
    
    return H->parent[v2]
}

int main(){
    GraphList *H=(GraphList*)malloc(sizeof(GraphList));
    H=Create_Graph(5,5);
    addvertex(H,0);
    addvertex(H,1);
    addvertex(H,2);
    addvertex(H,3);
    addedge(H,0,3,2);
    addedge(H,0,1,1);
    addedge(H,1,3,4);
    addedge(H,1,2,3);
    addedge(H,1,0,1);
    addedge(H,2,3,5);
    addedge(H,2,1,3);
    addedge(H,3,2,5);
    addedge(H,3,1,4);
    addedge(H,3,0,2);
    print_Graph(H);
    return 0;
}
#2021.03.16
//26번째 줄을 보면 그래프에 parent라는 배열을 추가시켰다. 이 배열은 각 노드가 결과적으로 가르키는 부모노드가 누구인가를 가르킨다
//예를들어 parent[2]와 parent[3] 의 값이 둘다 1로 같다면은 둘은 같은 그래프에속하고 부모노드가 1이라는 것을 의미한다.
//노트에 좀 끄적여보고 와서 완성해보겠다.
