-----------------------------------------------------------------------------------------------------------------------------
#start_time : 2021.05.04
#end_time : 
-----------------------------------------------------------------------------------------------------------------------------
#위상정렬이란?
//어떤 일을 하는 순서를 찾는 알고리즘.
//하나의 방향그래프에서는 여러 위상정렬이 가능하다.
-----------------------------------------------------------------------------------------------------------------------------
#배운점
-----------------------------------------------------------------------------------------------------------------------------
#내코드
#include <stdio.h>
#include <stdlib.h>

typedef struct node{
    int value;
    struct node *next;
}node;

typedef struct Que{
    node *head;
    node *front;
    node *rear;
}Que;

Que *Q=NULL;

node* create_node(int value){ //노드 생성
    node *newnode=(node*)malloc(sizeof(node));
    newnode->value=value;
    newnode->next=NULL;
    return newnode;
}

void Enqueue(int value){//젤 뒤 노드에 붙여준다.
    node *newnode=create_node(value);
    if(Q->front==NULL){
        Q->head=newnode;
        Q->front=newnode;
        Q->rear=newnode;
        return;
    }
    else{
        Q->rear->next=newnode;
        Q->rear=newnode;
        return;
    }
}
int Dequeue(){//젤앞노드것을 뺀다.
    if(Q->front==NULL){
        printf("아무것도 없습니다.\n");
        return -1;
    }
    int value;
    node *old_front;
    old_front=Q->front;
    value=Q->front->value;
    Q->head=Q->head->next;
    Q->front=Q->front->next;
    free(old_front);
    return value;
}

int peak(){//젤 앞의 값을 보여줌
    if(Q->front==NULL){
        printf("아무것도 없습니다.\n");
    }
    return Q->front->value;
}

typedef struct Node{
  int vertex;
  int enter_edge;
  struct Node *next;
}Node;

typedef struct Grape{
  Node **grape;
  int *enter_cnt;
}Grape;

Grape *H;
 int N=3;
int M=2;

Node* Create_Node(int a){
  Node *newNode=(Node*)malloc(sizeof(Node));
  newNode->enter_edge=0;
  newNode->vertex=a;
  newNode->next=NULL;
  return newNode;
}

void add(int a,int b){
  Node* newNode=Create_Node(b);
  newNode->next=H->grape[a];
  H->grape[a]=newNode;
  H->enter_cnt[b]++;
}

void print_Graph(){
    Node *horse;
    for(int i=1;i<=N;i++){
        horse=H->grape[i];
        printf("정점[%d]->",i);
        while(horse!=NULL){
            printf("%d-> ",horse->vertex);
            horse=horse->next;
        }
        printf("\n");
    }
    return;
}

void topological_sort(){
  Node *horse;
  Node *horse2;
  for(int i=1;i<=N;i++){
    if(H->enter_cnt[i]==0){
      Enqueue(i);
      horse=H->grape[i];
      while(horse){
        printf("101\n");
        H->enter_cnt[horse->vertex]--;
        horse=horse->next;
      }
    }
  }
  while(Q->front!=NULL){
    for(int i=1;i<=N;i++){
      printf("10\n");
      horse=H->grape[peak()];
      //printf("체크\n");
      if(H->enter_cnt[horse->vertex]==0){
        printf("체크\n");
        printf("20\n");
        Enqueue(horse->vertex);
        horse2=horse;
        while(horse2){
         printf("30\n");
         H->enter_cnt[horse2->vertex]--;
         horse2=horse2->next;
       }
        //앤큐한 벌텍스의 인접벌텍스들도 enter_cnt--해줘야함.
      }
      printf("%d\n",Dequeue());
    }
  }
}


int main(void) {
  H=(Grape*)malloc(sizeof(Grape));
  Q=(Que*)malloc(sizeof(Que));
 
  H->grape=(Node**)malloc(sizeof(Node*)*(N+1));
  H->enter_cnt=(int *)malloc(sizeof(int)*(N+1));
  int a,b;
  for(int i=0;i<M;i++){
    scanf("%d %d",&a,&b);
    add(a,b);
  }
  print_Graph();
  topological_sort();
  return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
#2021.05.04
//어떤 알고리즘인지 파악 후 만들어보려는데 쉽지않다..
#2021.05.06
//도저히 복잡해서 남들이 만들것을 봤는데 DFS를 이용한 방법을 이용했다.
//젤첫 순위부터 DFS를 이용해서 가장끝 노드까지 가서 끝노드부터 출력한다.
//출력하고 지나온 노드를 다시 역으로 올라오면서 하나씩 또 출력한다. 
//첫노드로 돌아오면 그다음 갈림길로 가서 다시 끝노드부터 출력한다. 단, 이미 출력한노드는 무시한다.
//모든 노드의 갈림길에 적용된다.
