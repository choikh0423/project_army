------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#문제
여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 
여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 
하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.
현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 
그렇지 않다면 바로 인쇄를 한다.
예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.

여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 
예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.

입력
첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.
테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다. 
이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.

출력
각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.

예제 입력 1 
3
1 0
5
4 2
1 2 3 4
6 0
1 1 9 1 1 1
예제 출력 1 
1
2
5
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#start_time : 2021.04.27
#end_time : 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#배운점
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#내코드
#include<stdio.h>
#include<stdlib.h>

typedef struct Node{
    int value;
    struct Node *next;
}Node;

typedef struct Que{
    Node *front;
    Node *rear;
}Que;



Que *Q=NULL;
int *data;
int prior[10];
int cnt=0;

Node* create_node(int value){ //노드 생성
    Node *newNode=(Node*)malloc(sizeof(Node));
    newNode->value=value;
    newNode->next=NULL;
    return newNode;
}

void Enqueue(int value){//젤 뒤 노드에 붙여준다.
    Node *newNode=create_node(value);
    if(Q->front==NULL){
        Q->front=newNode;
        Q->rear=newNode;
        return;
    }
    else{
        Q->rear->next=newNode;
        Q->rear=newNode;
        return;
    }
}
int Dequeue(){//젤앞노드것을 뺀다.
    if(Q->front==NULL){
        printf("아무것도 없습니다.\n");
        return -1;
    }
    int value;
    Node *old_front;
    old_front=Q->front;
    for(int i=data[Q->front->value]+1;i<=9;i++){
        if(prior[i]>0){
           // printf("더 중요한 문서가있습니다.\n");
            Q->rear->next=Q->front;
            Q->rear=Q->front;
            Q->front=Q->front->next;
            Q->rear->next=NULL;
            return -1;
        }
    }
    value=Q->front->value;
    Q->front=Q->front->next;
    free(old_front);
    //printf("%d %d %d ",value,data[value],prior[data[value]]);
    prior[data[value]]--;
    cnt++;
    return value;
}

int peak(){//젤 앞의 값을 보여줌
    if(Q->front==NULL){
        printf("아무것도 없습니다.\n");
    }
    return Q->front->value;
}

int main(){
    int N,M,L;
    scanf("%d ",&N);
    for(int a=0;a<N;a++){
        Q=(Que*)malloc(sizeof(Que));
        scanf("%d %d ",&M,&L);
        data=(int*)malloc(sizeof(int)*M);
        for(int i=0;i<10;i++){
            prior[i]=0;
        }
        
        
        for(int i=0;i<M;i++){
            scanf("%d ",&data[i]);
            prior[data[i]]++;
            Enqueue(i);
        }
        //printf("%d",peak());
        //printf("%d",prior[5]);
        while(Q->front!=NULL){
            if(Dequeue()==L){
                printf("%d",cnt);
                break;
            }
        }
    }
    return ;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#2021.04.27
//처음에 배열로 큐를 만들어서 해결할려고했다.
//하지만 만들어보니까 중요도가 때문에 계속 뒤로 밀릴경우 rear는 계속 늘어날 것이고 한정적인 크기의 배열로는 세그먼트폴트 오류가 날것이다.
//그래서 연결리스트 큐로 만들겠다.
//일단 수를 입력받을 때 중요도 배열 prior[]이라는 곳에 1~9까지 중요도가 몇개씩 중첩되가는지 체크해둔다.
//그 후 Deque할때 그 데이터의 중요도+1인덱스 부터 9까지 1이상이 있다면 높은중요도가 있는 것이기때문에 출력하지못하고 밀릴것이다.
//테스트케이스가 1개일때는 정상적으로 작동되는데 여러개일때는 잘안된다, 시간없어서 다음에와서 고치겠다.
