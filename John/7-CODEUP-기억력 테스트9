문제 설명    
진짜 오랜만에 주현이 엄마는 기억력 테스트를 하기로 했다.

주현이가 많이 컸기 때문에 이제 숫자만 가지고 테스트하기엔 부족하다.

이번에도 N개의 숫자를 불러주고, M개의 질문을 한다.

처음에 [단어]와 [숫자]를 불러주고, 질문으로 [단어]를 물어보면 해당 단어의 [숫자]를 말하는 것이다.

그런데 불러 줄 때 같은 [단어]가 나오는 경우 [이전 단어]의 [숫자]에 [현재 숫자]를 더해야 한다.

예를 들어 "ddobot 3" , "poketmon 5", "ddobot 7"을 불러 주고, 질문으로 "ddobot"을 물었을 경우 3+7인 10을 답해야 한다.

이번에는 포켓몬 썬&문  카드 풀 팩이 걸려 있다. 주현이가 잘 할 수 있도록 도와주자.

입력
첫째 줄에 N과 M이 입력된다.(1<=N,M<=100,000)

둘째 줄부터 N줄 동안 문자열 S와 정수 k가 입력된다. 

그 다음 M줄 동안 질문 Q가 문자열로 입력된다. 만약 부르지 않았던 단어를 질문하는 경우 0을 출력한다.

(S, Q는 100글자 이하 영어 소문자 알파벳으로만 구성, k는 10이하의 자연수)

출력
질문에 맞는 [누적 숫자]를 한줄에 하나씩 출력한다.

입력 예시   
3 4
ddobot 3
poketmon 5
ddobot 7
ddobot
poketmon
ddobot
hellocarbot

출력 예시
10
5
10
0

#start_time : 2021.02.28
#end time : 

#내코드
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node{
    int address;
    char data[100];
    int number;
}Node;

typedef struct HashTable{
    Node *node;
    int hashsize;
}HashTable;

HashTable* creat_hashtable(int size){
    HashTable *table=(HashTable*)malloc(sizeof(HashTable));
    table->node=(Node*)malloc(sizeof(Node)*size);
    table->hashsize=size;
    return table;
}

int convert_s(char a[]){
    int sum=0;
    for(int i=0;a[i]!=0;i++){
        sum=sum+(int)a[i];
    }
    return sum;
}

int Hashfuntion(char a[],int size){
    int key;
    key=convert_s(a);
    key=key%size;
    return key;
}

void InsertHash(HashTable *H,char a[],int num,int size){
    Node *p;
    int k;
    Node *n=(Node*)malloc(sizeof(Node));
    k=Hashfuntion(a,size);
    strcpy(n->data,a);
    n->number=num;
    n->address=k;
    H->node[k]=n;
}

int main() {
    int n,m;
    char name[100];
    int num;
    scanf("%d %d",&n,&m);
    HashTable *H=creat_hashtable(101);
    for(int i=0;i<n;i++){
        scanf(" %s %d",name,&num);
        printf("%d\n",convert_s(name));
        
    }
    
}

#2021.02.28
//이문제랑 제일 잘맞는 자료구조는 해시라고생각한다. 그래서 오늘부터 해시공부하고 풀도록하겠다.

#2021.03.01
//H->node[k]=n;
//error: incompatible types when assigning to type ‘Node’ from type ‘Node *
//위코드에서 이러한 에러가뜬다 분명 node는 Node를 가르키는 포인터Node*이고 n도 Node*타입인데도 불구하고 호환되지않는다고 하고 node[k]가 포인터형이 아니라고한다..

#2021.03.02
//오늘 너무피곤해서 그래도 조금은 와서 다른사람들은 어떻게 구현했는지 봤지만 아직 문제원인을 모르겠다.
