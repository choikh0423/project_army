#문제 설명    
지원이와 민서는 공교롭게도 지원이의 형인 주현이 그리고 민서의 언니인 민아와 각각 3살 차이다.
그리고 민서는 3살이다.
오빠와 언니는 민서를 위해 N 개의 공백으로 분리된 숫자열을 입력으로 준 다음 두 수의 합이 3으로 나누어 떨어지는 총 수를 알려주어 민서의 3살을 1년동안 축하해주려고 한다.

입력
첫 줄에 숫자들의 개수를 나타내는 정수 N이 입력된다. (1<=N<=8000)
둘 째 줄에 정수 N개가 공백을 두고 입력이 된다. (1<=Ni<=105)

출력
 두 수의 합이 3으로 나누어 떨어지는 총 경우의 수를 출력한다.

입력 예시   
5
1 4 2 3 3

출력 예시
3

도움말
입력이
3
3 3 3
이면 정답은 3

3
1 2 3
이면 정답은 1
이다.

#start_time : 2021.03.09 11:06
#end_time : 2021.03.09 11:53

#배운점
//처음에 생각한 것은 brute-force이다. 그냥 이중for문 돌리면 끝인데? 라는 생각이였지만 이때까지 공부한게 있으니 그 방법은 사용않기로했다.
//7-codeup-석차계산 문제에서 배운 것이 생각났다. 고정숫자를 이용해 푸는 것. 3으로 나눈 나머지 0,1,2라는 고정숫자를 이용해야겠다고 생각했다.
//이 이후는 여러가지 실패->반례찾기->실패->반례찾기..->성공으로 끝났다.
//실제로 문제에서 최대 갯수인 8000을 넣고 이중for vs 내 방식 을 비교했을 때 이중for문은 36~42 m/s이 나오는 반면 내코드는 6m/s~7m/s이 나왔다.
//다른 사람들은 그래프 이용해서 탐색알고리즘으로 푼것 같기도하다. 그래프를 배우고나서 다시한번 풀어보겠다.


#내코드(시간복잡도-O(n))

#include <stdio.h>
#include <stdlib.h>

int Mod3Array[3];//입력받은 값을 3으로 나눠서 0이면 [0]의 값을 1씩늘려준다(초기값은 0) 
int main() {
    int n,cnt=0;
    scanf("%d ",&n);
    int *k=(int *)malloc(sizeof(int)*n);
    for(int i=0;i<n;i++){
        scanf("%d ",&k[i]);
        Mod3Array[k[i]%3]++;//나눠서 0,1,2 인 것의 갯수를 카운트하는 것이다.
    }
    for(int i=0;i<n;i++){
        if(k[i]%3==0 ){
            cnt=cnt+Mod3Array[0]-1; // 나머지가 0이면 나머지가0인 다른 것과 더해야 3의배수가 된다. 단 자기 자신도 포함되어있으므로 -1;
            Mod3Array[0]-=1; //
        }
        else if(k[i]%3==1){ //나머지가 1이면 나머지가 2인 애랑 더해야 3의배수가 된다.
            if(Mod3Array[2]>0)cnt=cnt+Mod3Array[2]; // 나머지가 2인 값의 개수를 더해줌
            Mod3Array[1]-=1; // //k[i]는 다음수k[i+?]가 나머지가 2일때 나머지 1인애랑 더해야 할경우에 이미 한번 카운팅 됐기 때문에 제외되야한다. 그래서 -1.
        }
        else if(k[i%3]==2){ 
            if(Mod3Array[1]>0)cnt=cnt+Mod3Array[1];
            Mod3Array[2]-=1;
        }
    }
   
    printf("%d",cnt);
}
